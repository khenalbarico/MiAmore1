@using LogicLbrary1.MusicPlaylistHandler1
@inject MusicLibraryService Library
@inject MusicPlayerState PlayerState
@inject IJSRuntime JS

<div class="floating-player @(VisibleOnPlayTabOnly && !IsPlayTab ? "player-hidden" : "")"
     @ref="_root">

    <div class="fp-header">
        <div class="fp-title">🎀 Love Jukebox</div>
        <div class="fp-sub">
            @if (PlayerState.Current is not null)
            {
                <span><b>@PlayerState.Current.Artist</b> — @PlayerState.Current.MusicName</span>
            }
        </div>
    </div>

    <div class="fp-body">
        @if (PlayerState.Current is null)
        {
            <div class="fp-empty">Loading playlist...</div>
        }
        else
        {
            <div class="fp-comment">“@PlayerState.Current.Comment”</div>

            @if (_autoplayBlocked && !_isPlaying)
            {
                <button class="fp-btn fp-primary" @onclick="EnableMusic">
                    💗 Tap to enable music
                </button>
            }

            <div class="fp-controls">
                <button class="fp-btn" @onclick="Prev">⏮</button>
                <button class="fp-btn" @onclick="TogglePlay">
                    @(_isPlaying ? "⏸ Pause" : "▶ Play")
                </button>
                <button class="fp-btn" @onclick="Next">⏭</button>

                <button class="fp-btn fp-mini" @onclick="ToggleMinimize">
                    @(_minimized ? "🔼" : "🔽")
                </button>
            </div>

            <div class="fp-progress" style="display:@(_minimized ? "none" : "block")">
                <input type="range" min="0" max="1000" value="@_slider"
                       @oninput="OnSeekInput" />
                <div class="fp-time">@_timeLabel</div>
            </div>

            <div style="display:@(_minimized ? "none" : "block")" class="fp-playlist">
                @for (int i = 0; i < PlayerState.Playlist.Count; i++)
                {
                    var item = PlayerState.Playlist[i];
                    <button class="fp-track @(i == PlayerState.Index ? "active" : "")"
                            @onclick="(() => Pick(i))">
                        <div class="fp-track-title">@item.MusicName</div>
                        <div class="fp-track-artist">@item.Artist</div>
                    </button>
                }
            </div>

            <audio @ref="_audio"
                   src="@GetAudioSrc()"
                   preload="auto"
                   playsinline
                   muted="@_startMuted"
                   @onended="OnEnded">
            </audio>
        }
    </div>
</div>

@code {
    [Parameter] public bool IsPlayTab { get; set; }
    [Parameter] public bool VisibleOnPlayTabOnly { get; set; } = true;

    [Parameter] public bool AutoPlay { get; set; } = true;

    private ElementReference _root;
    private ElementReference _audio;

    private bool _isPlaying;
    private bool _minimized;

    private int _slider = 0;
    private string _timeLabel = "0:00 / 0:00";

    private CancellationTokenSource? _pollCts;

    private bool _jsReady;
    private bool _autoplayBlocked;
    private bool _startMuted = false; 

    protected override async Task OnInitializedAsync()
    {
        PlayerState.OnChange += StateHasChanged;

        if (!PlayerState.IsReady)
        {
            var list = await Library.GetAllAsync();
            PlayerState.SetPlaylist(list);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_jsReady)
        {
            try
            {
                await JS.InvokeVoidAsync("floatingPlayer.init", _root);
                _jsReady = true;
            }
            catch
            {
                return;
            }
        }

        if (firstRender)
        {
            _pollCts = new CancellationTokenSource();
            _ = Task.Run(() => PollProgressLoop(_pollCts.Token));

            if (AutoPlay)
            {
                await Task.Yield();
                await TryAutoPlay();
            }
        }
    }

    private string GetAudioSrc()
    {
        var dir = PlayerState.Current?.Directory ?? "";
        if (string.IsNullOrWhiteSpace(dir)) return "";
        return dir.StartsWith("/") ? dir : "/" + dir;
    }

    private async Task TryAutoPlay()
    {
        if (!_jsReady || PlayerState.Current is null) return;

        try
        {
            await JS.InvokeVoidAsync("floatingPlayer.setSrc", _audio, GetAudioSrc());

            var result = await JS.InvokeAsync<PlayResult>("floatingPlayer.play", _audio);
            if (result?.Ok == true)
            {
                _isPlaying = true;
                _autoplayBlocked = false;
            }
            else
            {
                _isPlaying = false;
                _autoplayBlocked = true; 
            }
        }
        catch
        {
            _autoplayBlocked = true;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task EnableMusic()
    {
        _startMuted = false;
        _autoplayBlocked = false;
        await TogglePlay();
    }

    private async Task TogglePlay()
    {
        if (!_jsReady || PlayerState.Current is null) return;

        if (_isPlaying)
        {
            await JS.InvokeVoidAsync("floatingPlayer.pause", _audio);
            _isPlaying = false;
        }
        else
        {
            var result = await JS.InvokeAsync<PlayResult>("floatingPlayer.play", _audio);
            _isPlaying = result?.Ok == true;
            _autoplayBlocked = !_isPlaying;
        }
    }

    private async Task Next()
    {
        if (!_jsReady || PlayerState.Current is null) return;

        var wasPlaying = _isPlaying;
        PlayerState.Next();

        await JS.InvokeVoidAsync("floatingPlayer.setSrc", _audio, GetAudioSrc());
        if (wasPlaying)
        {
            var r = await JS.InvokeAsync<PlayResult>("floatingPlayer.play", _audio);
            _isPlaying = r?.Ok == true;
        }
        else _isPlaying = false;
    }

    private async Task Prev()
    {
        if (!_jsReady || PlayerState.Current is null) return;

        var wasPlaying = _isPlaying;
        PlayerState.Prev();

        await JS.InvokeVoidAsync("floatingPlayer.setSrc", _audio, GetAudioSrc());
        if (wasPlaying)
        {
            var r = await JS.InvokeAsync<PlayResult>("floatingPlayer.play", _audio);
            _isPlaying = r?.Ok == true;
        }
        else _isPlaying = false;
    }

    private async Task Pick(int i)
    {
        if (!_jsReady || PlayerState.Current is null) return;

        var wasPlaying = _isPlaying;
        PlayerState.SetIndex(i);

        await JS.InvokeVoidAsync("floatingPlayer.setSrc", _audio, GetAudioSrc());
        if (wasPlaying)
        {
            var r = await JS.InvokeAsync<PlayResult>("floatingPlayer.play", _audio);
            _isPlaying = r?.Ok == true;
        }
        else _isPlaying = false;
    }

    private void ToggleMinimize() => _minimized = !_minimized;

    private async Task OnEnded() => await Next();

    private async Task OnSeekInput(ChangeEventArgs e)
    {
        if (!_jsReady) return;
        if (e.Value is null) return;
        if (!int.TryParse(e.Value.ToString(), out var v)) return;
        _slider = v;

        await JS.InvokeVoidAsync("floatingPlayer.seekBySlider", _audio, _slider);
    }

    private async Task PollProgressLoop(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            try
            {
                if (_jsReady && PlayerState.Current is not null)
                {
                    var info = await JS.InvokeAsync<PlayerProgress>("floatingPlayer.getProgress", _audio);

                    _slider = info.Duration <= 0 ? 0 : (int)Math.Round((info.CurrentTime / info.Duration) * 1000.0);
                    _timeLabel = $"{FormatTime(info.CurrentTime)} / {FormatTime(info.Duration)}";

                    await InvokeAsync(StateHasChanged);
                }
            }
            catch { }

            try { await Task.Delay(350, ct); } catch { }
        }
    }

    private static string FormatTime(double seconds)
    {
        if (seconds < 0) seconds = 0;
        var ts = TimeSpan.FromSeconds(seconds);
        if (ts.TotalHours >= 1) return $"{(int)ts.TotalHours}:{ts.Minutes:D2}:{ts.Seconds:D2}";
        return $"{ts.Minutes}:{ts.Seconds:D2}";
    }

    public void Dispose()
    {
        PlayerState.OnChange -= StateHasChanged;
        _pollCts?.Cancel();
        _pollCts?.Dispose();
    }

    private sealed class PlayerProgress
    {
        public double CurrentTime { get; set; }
        public double Duration { get; set; }
    }

    private sealed class PlayResult
    {
        public bool Ok { get; set; }
        public string? Reason { get; set; }
    }
}
