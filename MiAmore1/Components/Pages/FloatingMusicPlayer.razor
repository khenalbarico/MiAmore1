@using LogicLbrary1.MusicPlaylistHandler1
@inject MusicLibraryService Library
@inject MusicPlayerState PlayerState
@inject IJSRuntime JS

<div class="floating-player @(VisibleOnPlayTabOnly && !IsPlayTab ? "player-hidden" : "")"
     @ref="_root">

    <div class="fp-header">
        <div class="fp-title">Love Music Player</div>
        <div class="fp-sub">
            @if (PlayerState.Current is not null)
            {
                <span><b>@PlayerState.Current.Artist</b> — @PlayerState.Current.MusicName</span>
            }
        </div>
    </div>

    <div class="fp-body">
        @if (PlayerState.Current is null)
        {
            <div class="fp-empty">Loading playlist...</div>
        }
        else
        {
            <div class="fp-comment">“@PlayerState.Current.Comment”</div>

            <div class="fp-controls">
                <button class="fp-icon-btn" @onclick="Prev" type="button" aria-label="Previous">⏮</button>

                <button class="fp-play-btn" @onclick="TogglePlay" type="button" aria-label="Play/Pause">
                    <span class="fp-play-icon">@(_isPlaying ? "⏸" : "▶")</span>
                    <span class="fp-play-text">@(_isPlaying ? "Pause" : "Play")</span>
                </button>

                <button class="fp-icon-btn" @onclick="Next" type="button" aria-label="Next">⏭</button>

                <div class="fp-volume" aria-label="Volume">
                    <span class="fp-vol-ico">🔊</span>
                    <input class="fp-vol-range" type="range" min="0" max="100" value="@_volume"
                           @onchange="OnVolumeChange" />
                    <span class="fp-vol-val">@_volume%</span>
                </div>
            </div>

            <div class="fp-progress">
                <input class="fp-seek" type="range" min="0" max="1000" value="@_slider"
                       @onpointerdown="BeginSeek"
                       @onpointerup="EndSeek"
                       @onchange="OnSeekChange" />
                <div class="fp-time">@_timeLabel</div>
            </div>

            <audio @ref="_audio"
                   src="@GetAudioSrc()"
                   preload="auto"
                   playsinline
                   muted="@_startMuted"
                   @onended="OnEnded">
            </audio>
        }
    </div>
</div>

@code {
    [Parameter] public bool IsPlayTab { get; set; }
    [Parameter] public bool VisibleOnPlayTabOnly { get; set; } = true;
    [Parameter] public bool AutoPlay { get; set; } = true;

    private ElementReference _root;
    private ElementReference _audio;

    private bool _isPlaying;
    private bool _isSeeking;

    private int _slider = 0;
    private string _timeLabel = "0:00 / 0:00";
    private int _volume = 85;

    private CancellationTokenSource? _pollCts;

    private bool _jsReady;
    private bool _startMuted = true;
    private bool _unmuteHooked;
    private bool _triedAutoPlay;

    protected override async Task OnInitializedAsync()
    {
        PlayerState.OnChange += StateHasChanged;

        var list = await Library.GetAllAsync(forceReload: true);
        PlayerState.SetPlaylist(Shuffle(list));
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_jsReady)
        {
            try
            {
                await JS.InvokeVoidAsync("floatingPlayer.init", _root);
                _jsReady = true;
            }
            catch
            {
                return;
            }
        }

        if (firstRender)
        {
            _pollCts = new CancellationTokenSource();
            _ = Task.Run(() => PollProgressLoop(_pollCts.Token));
        }

        if (_jsReady && PlayerState.Current is not null)
        {
            await JS.InvokeVoidAsync("floatingPlayer.setVolume", _audio, _volume / 100.0);
        }

        if (AutoPlay && !_triedAutoPlay && PlayerState.Current is not null && _jsReady)
        {
            _triedAutoPlay = true;
            await JS.InvokeVoidAsync("floatingPlayer.setSrc", _audio, GetAudioSrc());
            await TryAutoPlayMuted();
            await EnsureUnmuteOnFirstInteraction();
        }
    }

    private static IReadOnlyList<T> Shuffle<T>(IReadOnlyList<T> source)
    {
        var list = source.ToList();
        var rng = Random.Shared;
        for (var i = list.Count - 1; i > 0; i--)
        {
            var j = rng.Next(i + 1);
            (list[i], list[j]) = (list[j], list[i]);
        }
        return list;
    }

    private string GetAudioSrc()
    {
        var dir = PlayerState.Current?.Directory ?? "";
        if (string.IsNullOrWhiteSpace(dir)) return "";
        return dir.StartsWith("/") ? dir : "/" + dir;
    }

    private async Task TryAutoPlayMuted()
    {
        try
        {
            await JS.InvokeVoidAsync("floatingPlayer.setMuted", _audio, true);
            var result = await JS.InvokeAsync<PlayResult>("floatingPlayer.play", _audio);
            _isPlaying = result?.Ok == true;
        }
        catch
        {
            _isPlaying = false;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task EnsureUnmuteOnFirstInteraction()
    {
        if (_unmuteHooked) return;
        _unmuteHooked = true;

        try
        {
            var src = GetAudioSrc();
            await JS.InvokeVoidAsync("floatingPlayer.unmuteOnFirstGesture", _audio, src);
        }
        catch { }
    }

    private async Task TogglePlay()
    {
        if (!_jsReady || PlayerState.Current is null) return;

        if (_isPlaying)
        {
            await JS.InvokeVoidAsync("floatingPlayer.pause", _audio);
            _isPlaying = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        await JS.InvokeVoidAsync("floatingPlayer.setMuted", _audio, false);
        var result = await JS.InvokeAsync<PlayResult>("floatingPlayer.play", _audio);
        _isPlaying = result?.Ok == true;

        await InvokeAsync(StateHasChanged);
    }

    private async Task Next()
    {
        if (!_jsReady || PlayerState.Current is null) return;

        var wasPlaying = _isPlaying;
        PlayerState.Next();

        await JS.InvokeVoidAsync("floatingPlayer.setSrc", _audio, GetAudioSrc());
        await JS.InvokeVoidAsync("floatingPlayer.setVolume", _audio, _volume / 100.0);

        if (wasPlaying)
        {
            await JS.InvokeVoidAsync("floatingPlayer.setMuted", _audio, false);
            var r = await JS.InvokeAsync<PlayResult>("floatingPlayer.play", _audio);
            _isPlaying = r?.Ok == true;
        }
        else
        {
            _isPlaying = false;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task Prev()
    {
        if (!_jsReady || PlayerState.Current is null) return;

        var wasPlaying = _isPlaying;
        PlayerState.Prev();

        await JS.InvokeVoidAsync("floatingPlayer.setSrc", _audio, GetAudioSrc());
        await JS.InvokeVoidAsync("floatingPlayer.setVolume", _audio, _volume / 100.0);

        if (wasPlaying)
        {
            await JS.InvokeVoidAsync("floatingPlayer.setMuted", _audio, false);
            var r = await JS.InvokeAsync<PlayResult>("floatingPlayer.play", _audio);
            _isPlaying = r?.Ok == true;
        }
        else
        {
            _isPlaying = false;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task OnEnded() => await Next();

    private void BeginSeek() => _isSeeking = true;

    private void EndSeek() => _isSeeking = false;

    private async Task OnSeekChange(ChangeEventArgs e)
    {
        if (!_jsReady) return;
        if (e.Value is null) return;
        if (!int.TryParse(e.Value.ToString(), out var v)) return;

        _slider = v;
        await JS.InvokeVoidAsync("floatingPlayer.seekBySlider", _audio, _slider);
    }

    private async Task OnVolumeChange(ChangeEventArgs e)
    {
        if (!_jsReady) return;
        if (e.Value is null) return;
        if (!int.TryParse(e.Value.ToString(), out var v)) return;

        if (v < 0) v = 0;
        if (v > 100) v = 100;

        _volume = v;
        await JS.InvokeVoidAsync("floatingPlayer.setVolume", _audio, _volume / 100.0);
        await InvokeAsync(StateHasChanged);
    }

    private async Task PollProgressLoop(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            try
            {
                if (_jsReady && PlayerState.Current is not null)
                {
                    var info = await JS.InvokeAsync<PlayerProgress>("floatingPlayer.getProgress", _audio);

                    if (!_isSeeking)
                    {
                        _slider = info.Duration <= 0 ? 0 : (int)Math.Round((info.CurrentTime / info.Duration) * 1000.0);
                    }

                    _timeLabel = $"{FormatTime(info.CurrentTime)} / {FormatTime(info.Duration)}";

                    await InvokeAsync(StateHasChanged);
                }
            }
            catch { }

            try { await Task.Delay(350, ct); } catch { }
        }
    }

    private static string FormatTime(double seconds)
    {
        if (seconds < 0) seconds = 0;
        var ts = TimeSpan.FromSeconds(seconds);
        if (ts.TotalHours >= 1) return $"{(int)ts.TotalHours}:{ts.Minutes:D2}:{ts.Seconds:D2}";
        return $"{ts.Minutes}:{ts.Seconds:D2}";
    }

    public void Dispose()
    {
        PlayerState.OnChange -= StateHasChanged;
        _pollCts?.Cancel();
        _pollCts?.Dispose();
    }

    private sealed class PlayerProgress
    {
        public double CurrentTime { get; set; }
        public double Duration { get; set; }
    }

    private sealed class PlayResult
    {
        public bool Ok { get; set; }
        public string? Reason { get; set; }
    }
}
